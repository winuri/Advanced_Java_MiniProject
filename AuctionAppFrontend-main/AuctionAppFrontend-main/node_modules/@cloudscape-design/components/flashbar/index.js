import { __assign, __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import clsx from 'clsx';
import React, { useEffect, useRef, useState } from 'react';
import { applyDisplayName } from '../internal/utils/apply-display-name';
import customCssProps from '../internal/generated/custom-css-properties';
import { Flash, focusFlashById } from './flash';
import { getBaseProps } from '../internal/base-component';
import InternalIcon from '../icon/internal';
import { TIMEOUT_FOR_ENTERING_ANIMATION } from './constant';
import { TransitionGroup } from 'react-transition-group';
import { Transition } from '../internal/components/transition';
import useBaseComponent from '../internal/hooks/use-base-component';
import { useContainerBreakpoints } from '../internal/hooks/container-queries';
import useFocusVisible from '../internal/hooks/focus-visible';
import { useMergeRefs } from '../internal/hooks/use-merge-refs';
import { useReducedMotion, useVisualRefresh } from '../internal/hooks/use-visual-mode';
import { getVisualContextClassname } from '../internal/components/visual-context';
import styles from './styles.css.js';
export default function Flashbar(_a) {
    var items = _a.items, restProps = __rest(_a, ["items"]);
    var __internalRootRef = useBaseComponent('Flashbar').__internalRootRef;
    var baseProps = getBaseProps(restProps);
    var ref = useRef(null);
    var _b = useContainerBreakpoints(['xs']), breakpoint = _b[0], breakpointRef = _b[1];
    var mergedRef = useMergeRefs(ref, breakpointRef, __internalRootRef);
    var isFocusVisible = useFocusVisible();
    var isVisualRefresh = useVisualRefresh();
    var _c = useState(items), previousItems = _c[0], setPreviousItems = _c[1];
    var _d = useState(null), nextFocusId = _d[0], setNextFocusId = _d[1];
    // Track new or removed item IDs in state to only trigger focus changes for newly added items.
    // https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops
    if (items) {
        var newItems = items.filter(function (_a) {
            var id = _a.id;
            return id && !previousItems.some(function (item) { return item.id === id; });
        });
        var removedItems = previousItems.filter(function (_a) {
            var id = _a.id;
            return id && !items.some(function (item) { return item.id === id; });
        });
        if (newItems.length > 0 || removedItems.length > 0) {
            setPreviousItems(items);
            var newFocusItems = newItems.filter(function (_a) {
                var ariaRole = _a.ariaRole;
                return ariaRole === 'alert';
            });
            if (newFocusItems.length > 0) {
                setNextFocusId(newFocusItems[0].id);
            }
        }
    }
    useEffect(function () {
        if (nextFocusId) {
            focusFlashById(ref.current, nextFocusId);
        }
    }, [nextFocusId]);
    /**
     * All the flash items should have ids so we can identify which DOM element is being
     * removed from the DOM to animate it. Motion will be disabled if any of the provided
     * flash messages does not contain an `id`.
     */
    var motionDisabled = useReducedMotion(breakpointRef) || !isVisualRefresh || (items && !items.every(function (item) { return 'id' in item; }));
    /**
     * The `stackItems` property is a hidden boolean that allows for teams
     * to beta test the flashbar stacking feature.
     */
    var stackItems = isStackedFlashbar(restProps);
    var ariaLabels = stackItems ? restProps.ariaLabels : {};
    var isFlashbarStacked = stackItems && (items === null || items === void 0 ? void 0 : items.length) > 3;
    var _e = useState(false), isFlashbarStackExpanded = _e[0], setIsFlashbarStackExpanded = _e[1];
    /**
     * Compute the appropriate aria label for the stacked notifications toggle button
     * based on the expanded/collapsed state of the stack and the presence of
     * corresponding aria label properties.
     */
    function getStackButtonAriaLabel() {
        var _a, _b;
        var stackButtonAriaLabel;
        if (isFlashbarStackExpanded) {
            stackButtonAriaLabel = (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.stackCollapseLabel) !== null && _a !== void 0 ? _a : 'Collapse stacked notifications';
        }
        else {
            stackButtonAriaLabel = (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.stackExpandLabel) !== null && _b !== void 0 ? _b : 'Expand stacked notifications';
        }
        return stackButtonAriaLabel;
    }
    /**
     * If the `isFlashbarStacked` is true (which is only possible if `stackItems` is true)
     * then the first item should be rendered followed by two dummy items that visually indicate
     * two, three, or more items exist in the stack.
     */
    function renderStackedItems() {
        var _a;
        if (!isFlashbarStacked) {
            return;
        }
        var stackDepth = Math.min(3, items.length);
        var stackedItems = items.slice(0, stackDepth);
        return (React.createElement("div", { className: styles.stack, style: (_a = {}, _a[customCssProps.flashbarStackDepth] = stackDepth, _a) },
            !isFlashbarStackExpanded && (React.createElement("div", { className: clsx(styles.collapsed, isVisualRefresh && styles['visual-refresh']) }, stackedItems.map(function (item, index) {
                var _a;
                var _b, _c;
                return (React.createElement("div", { className: styles.item, style: (_a = {}, _a[customCssProps.flashbarStackIndex] = index, _a), key: index },
                    index === 0 && (React.createElement("ul", { className: styles['flash-list'] },
                        React.createElement("li", { className: styles['flash-list-item'] }, renderItem(item, (_b = item.id) !== null && _b !== void 0 ? _b : index)))),
                    index > 0 && React.createElement("div", { className: clsx(styles.flash, styles["flash-type-".concat((_c = item.type) !== null && _c !== void 0 ? _c : 'info')]) })));
            }))),
            isFlashbarStackExpanded && (React.createElement("ul", { className: clsx(styles['flash-list'], styles.expanded) }, items.map(function (item, index) {
                var _a, _b;
                return (React.createElement("li", { key: (_a = item.id) !== null && _a !== void 0 ? _a : index, className: styles['flash-list-item'] }, renderItem(item, (_b = item.id) !== null && _b !== void 0 ? _b : index)));
            }))),
            React.createElement("button", __assign({ "aria-label": getStackButtonAriaLabel(), className: clsx(styles.toggle, isVisualRefresh && styles['visual-refresh']), onClick: function () { return setIsFlashbarStackExpanded(!isFlashbarStackExpanded); } }, isFocusVisible),
                React.createElement("span", { className: clsx(styles.icon, isFlashbarStackExpanded && styles.expanded) },
                    React.createElement(InternalIcon, { size: "small", name: "angle-down" })))));
    }
    /**
     * If the flashbar is flat and motion is `enabled` then the adding and removing of items
     * from the flashbar will render with visual transitions.
     */
    function renderFlatItemsWithTransitions() {
        if (isFlashbarStacked || motionDisabled || !items) {
            return;
        }
        return (
        // This is a proxy for <ul>, so we're not applying a class to another actual component.
        // eslint-disable-next-line react/forbid-component-props
        React.createElement(TransitionGroup, { component: "ul", className: styles['flash-list'] }, items &&
            items.map(function (item, index) {
                var _a;
                return (React.createElement(Transition, { transitionChangeDelay: { entering: TIMEOUT_FOR_ENTERING_ANIMATION }, key: (_a = item.id) !== null && _a !== void 0 ? _a : index, "in": true }, function (state, transitionRootElement) {
                    var _a;
                    return (React.createElement("li", { className: styles['flash-list-item'] }, renderItem(item, (_a = item.id) !== null && _a !== void 0 ? _a : index, transitionRootElement, state)));
                }));
            })));
    }
    /**
     * If the flashbar is flat and motion is `disabled` then the adding and removing of items
     * from the flashbar will render without visual transitions.
     */
    function renderFlatItemsWithoutTransitions() {
        if (isFlashbarStacked || !motionDisabled || !items) {
            return;
        }
        return (React.createElement("ul", { className: styles['flash-list'] }, items.map(function (item, index) {
            var _a, _b;
            return (React.createElement("li", { key: (_a = item.id) !== null && _a !== void 0 ? _a : index, className: styles['flash-list-item'] }, renderItem(item, (_b = item.id) !== null && _b !== void 0 ? _b : index)));
        })));
    }
    /**
     * This is a shared render function for a single flashbar item to be used
     * by the stacking, motion, and non-motion item group render functions.
     */
    function renderItem(item, key, transitionRootElement, transitionState) {
        return (React.createElement(Flash
        // eslint-disable-next-line react/forbid-component-props
        , __assign({ 
            // eslint-disable-next-line react/forbid-component-props
            className: clsx(getVisualContextClassname('flashbar'), isVisualRefresh ? styles['flash-refresh'] : ''), key: key, ref: transitionRootElement, transitionState: transitionState }, item)));
    }
    return (React.createElement("div", __assign({}, baseProps, { className: clsx(baseProps.className, styles.flashbar, styles["breakpoint-".concat(breakpoint)]), ref: mergedRef }),
        renderStackedItems(),
        renderFlatItemsWithTransitions(),
        renderFlatItemsWithoutTransitions()));
}
function isStackedFlashbar(props) {
    return 'stackItems' in props && !!props.stackItems;
}
applyDisplayName(Flashbar, 'Flashbar');
//# sourceMappingURL=index.js.map